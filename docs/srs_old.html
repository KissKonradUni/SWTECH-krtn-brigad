<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Szoftver követelmény specifikáció</title>
    <style>
        html, body, li {
            font-size: 14px;
        }

        h1 {
            font-size: 16pt;
        }

        h2 {
            font-family: "Arial", sans-serif;
            font-size: 14px;
            font-weight: lighter;

            margin-bottom: 40px;
        }

        p {
            font-size: 14px;
        }
    </style>
</head>
<body>
    <p>
        <a href="h3.html">Vissza</a>
    </p>

    <br>
    <h1>KRTN Brigád - Szoftver követelmény specifikáció</h1>
    <h2>Software Requirement Specification</h2>
    <br>
    <h3>Készítették: </h3>
    <p> - Csákó Balázs</p>
    <p> - Bodnár Gergely</p>
    <p> - Kola Sándor</p>
    <p> - Kiss Konrád Soma</p>
    <br><br><br>
    <br><br><br>

    <h1>Tartalomjegyzék</h1>
    <h2>Table of contents</h2>
    <p>1. Bevezetés</p>
    <p>2. Áttekintés</p>
    <p>3. A rendszer funkciói</p>
    <p>3.1. Első követelmény</p>
    <p>3.2. Második követelmény</p>
    <p>3.3. Harmadik követelmény</p>
    <p>3.4. Harmadik követelmény</p>
    <p>3.5. Harmadik követelmény</p>
    <p>4. Használhatóság</p>
    <p>4.1. Betanulás nehézsége</p>
    <p>4.2. Összehasonlítás más módszerekkel</p>
    <p>4.3. Betanulást segítő eszközök</p>
    <p>4.4. Más alkalmazások, amelyeket használunk a fejlesztés során</p>
    <p>5. Megbízhatóság</p>
    <p>6. Teljesítmény</p>
    <p>7. Támogatottság</p>
    <p>8. Tervezési korlátozások</p>
    <p>9. Online dokumentáció</p>
    <p>10. Felhasznált kész komponensek</p>
    <p>11. Interfészek</p>
    <p>11.1. Felhasználói interfészek</p>
    <p>11.2. Hardver interfészek</p>
    <p>11.3. Szoftver interfészek</p>
    <p>12. Alkalmazott szabványok</p>
    <p>12.1. Kötelezően alkalmazandó szabványok</p>
    <p>12.2. Választás alapján alkalmazott szabványok</p>
    <p>13. Mellékletek</p>
    <br>

    <h1>1. Bevezetés</h1>
    <h2>Introduction</h2>

    <p>
        Mi itt a KTRN brigád csapatával egy multi-purpose 3D-s játékmotort próbálunk készíteni OpenGL és Java használatával.
        Ez a dokumentum ennek a projektnek a megfelelő megtervezését alapozza meg.
    </p>
    <br>

    <h1>2. Áttekintés</h1>
    <h2>Overview</h2>

    <p>
        A játékmotor kigondolásakor a következő szempontokat vettük figyelembe:
    </p>
    <ul>
        <li>Java nyelven még nincs sok konkurencia a téren.</li>
        <li>A konkurencián belül olyan pedig még annyira se, amely pont azokat a funkciókat tartalmazza amelyeket mi szeretnénk.</li>
        <li>OpenGL-t használunk a 3D-s grafikához.</li>
        <li>A játékmotorunknak több platformon is működnie kell.</li>
        <li>Gyorsnak kell maradnia régebbi gépeken is.</li>
    </ul>
    <br>

    <h1>3. A rendszer funkciói</h1>
    <h2>Specific Requirements</h2>

    <p>
        A játékmotorunknak a következő funkciókat kell tudnia:
    </p>
    <ul>
        <li>Jó minőségű 3D-s grafika megjelenítése.</li>
        <li>3D-s modellek, textúrák, animációk, hangok natív támogatása.</li>
        <li>ECS (Entity Component System) architektúra használata.</li>
        <li>Könnyű bővíthetőség a modolhatóság érdekében.</li>
        <li>Beépített állapotmentés/fájlrendszerkezelés.</li>
    </ul>
    <br>

    <h1>3.1. Első követelmény: Jó minőségű 3D-s grafika megjelenítése.</h1>
    <h2>First Requirement: Good quality 3D graphics</h2>

    <p>Ez a követelmény egy elég tágas fogalom, de a mi esetünkben a következőket jelenti:</p>
    <ul>
        <li>PBR, azaz Physically Based Rendering alkalmazása, azaz a fények és árnyékok fizikai alapokon való számítása.</li>
        <li>Ehhez minden anyag rendelkezik egy diffuse, normal, metallic, roughness és emissive textúrával, amelyek gyakorlatilag a standard a jelenlegi magas minőségű 3D-s grafikát használó játékokban.</li>
        <li>Ezentúl egyszerre akarunk alkalmazni Real-Time és Baked megvilágítást is, amelyeket a játékfejlesztők tudnak majd kontrollálni.</li>
        <li>Módosítható Render-Pipeline, amellyel a fejlesztők képesek lesznek egyéb effektusokat, vagy Post-Processing effektusokat hozzáadni a játékhoz.</li>
    </ul>
    <br>

    <h1>3.2. Második követelmény: 3D-s modellek, textúrák, animációk, hangok natív támogatása.</h1>
    <h2>Second Requirement: Native support for 3D models, textures, animations, sounds.</h2>

    <p>
        Ez alatt arra kell gondolni, hogy a manapság elterjedt és gyakran alkalmazott formátumakot minimális konverzióval,
        vagy teljesen konverziómentes módon képes kell hogy kezelje. Ehhez az ASSIMP nevű könyvtárat fogjuk használni,
        amely képes a legtöbb 3D-s formátumot kezelni. Ezentúl az STBI könyvtárat fogjuk használni a képek betöltéséhez,
        amely képes a legtöbb képformátumot kezelni. A többi fájt, mint a hangokat és animációkat,
        még nem döntöttük el, hogy milyen formátumban fogjuk tárolni.
    </p>
    <br>

    <h1>3.3. Harmadik követelmény: ECS (Entity Component System) architektúra használata.</h1>
    <h2>Third Requirement: Use of ECS (Entity Component System) architecture.</h2>

    <p>
        Az ECS architektúra lehetővé teszi a fejlesztők számára egy újrahasználható, könnyen bővíthető, és könnyen
        karbantartható kódbázis létrehozását. Az ECS architektúra lényege, hogy a játékban minden objektumot, vagyis
        entitást komponensekkel ruházunk fel, amelyek eldöntik a szerepét. Ezek újrahasználhatóságának köszönhetően nem
        kell minden objektumot külön-külön megírni. Például ha van egy Rajzoló komponensünk, akkor a játékban minden
        objektumot, amelyet meg szeretnénk jeleníteni, felruházunk ezzel a komponenssel, és a játék automatikusan
        kirajzolja azokat. Ezen kívül a komponenseknek lehetnek gyerekeik, amelyek további funkciókat adnak a szülő
        komponensnek. Például ha van egy Fizika komponensünk, akkor a játékban minden objektumot, amelyet meg szeretnénk
        mozgatni, felruházunk ezzel a komponenssel, és a játék automatikusan mozgatja azokat.
    </p>
    <br>

    <h1>3.4. Negyedik követelmény: Könnyű bővíthetőség a modolhatóság érdekében.</h1>
    <h2>Fourth Requirement: Easy expandability for modding purposes.</h2>

    <p>
        A játékmotorunknak modolhatónak kell lennie, azaz a játékfejlesztőknek könnyen kell tudniuk bővíteni a játékot.
        Ehhez a játékmotorunknak egy olyan API-t kell biztosítania, amelyen keresztül a játékfejlesztők képesek lesznek
        a játékot bővíteni a forráskód módosítása nélkül. Ez azt jelenti hogy amennyiben a használható komponensek és
        rendszerek már készen állnak, azok felhasználhatóvá kell hogy váljanak futásidő során betöltésre kerülő modulok
        és szkriptek számára. A pályák, objektumok és egyéb elemek betöltéséhez egy olyan fájlformátumot kell
        biztosítanunk, amelyben ezek az elemek leírhatóak.
    </p>
    <br>

    <h1>3.5. Ötödik követelmény: Beépített állapotmentés/fájlrendszerkezelés.</h1>
    <h2>Fifth Requirement: Built-in state saving/file system management.</h2>

    <p>
        Az előző pontra építve, a játékmotorunknak beépített fájlrendszerkezelőt kell tartalmaznia, amely képes
        kezelni a játékban használt fájlokat, és a játékfejlesztőknek lehetőséget kell biztosítania a játékállapot
        mentésére, és betöltésére. Ez azt jelenti, hogyha például a játékos több Entitásból épül fel, akkor azokat
        egy fájl formájában el kell tudni menteni, és később vissza kell tudni tölteni.
    </p>
    <br>

    <h1>4. Használhatóság</h1>
    <h2>Usability</h2>

    <h1>4.1. Betanulás nehézsége</h1>
    <h2>Learning difficulty</h2>

    <p>
        A játékmotorunkat úgy tervezzük, hogy a játékfejlesztőknek ne legyen nehéz megtanulni használni.
        Ezért egy könnyen érthető, tisztán angol nyelvű JavaDocs dokumentációval fog rendelkezni a motor.
        Ezentúl a motorhoz több példaprojekt is elérhető lesz, amelyek bemutatják a motor használatát.
        A motort úgy fogjuk kialakítani, hogy hasonlítson más, már a piacon lévő játékmotorokra, így a
        játékfejlesztőknek nem kell teljesen új módszereket megtanulniuk.
    </p>
    <br>

    <h1>4.2. Összehasonlítás más módszerekkel</h1>
    <h2>Comparison with other methods</h2>

    <p>
        A játékmotorunk a piacon már kitesztelt, alkalmazott és jól bevált módszereket fog alkalmazni.
        Ennek köszönhetően a tanulási-görbe nem lesz nagyon meredek.
    </p>
    <br>

    <h1>4.3. Betanulást segítő eszközök</h1>
    <h2>Learning aids</h2>

    <p>
        Idézet a 4.1.-es pontból:<br>
        "A játékmotorunkhoz egy könnyen érthető, tisztán angol nyelvű JavaDocs dokumentáció lesz elérhető.
        Ezen kívül a motorhoz több példaprojekt is elérhető lesz, amelyek bemutatják a motor használatát."
    </p>
    <br>

    <h1>4.4. Más alkalmazások, amelyeket használunk a fejlesztés során</h1>
    <h2>Other applications we use during development</h2>

    <p>
        A játékmotorunk fejlesztése során a következő alkalmazásokat használjuk:
    </p>
    <ul>
        <li>
            <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a> - A játékmotorunk fejlesztéséhez használt IDE.
            Könnyen elérhető, gyakran használt és jól bevált IDE.
        </li>
        <li>
            <a href="https://www.blender.org/">Blender</a> - A játékmotorunkhoz használt 3D-s modellek készítéséhez
            használt alkalmazás. Ingyenes, remekül támogatja a kívánt fájlformátumokat, és már a modellek anyagait is
            beállíthatjuk szerkesztés közben benne.
        </li>
    </ul>
    <br>

    <h1>5. Megbízhatóság</h1>
    <h2>Reliability</h2>

    <ul>
        <li>
            Rendelkezésre állás: A teljes használhatóság korlátozott lesz abban, hogy a fejlesztőknek melyek lesznek
            azok a dolgok, amelyeket maguknak kell megoldaniuk, de ez projektenként eltér szóval egységes mércét nem
            tudunk alkalmazni.
        </li>
        <li>
            MTBF: (Mean Time Between Failures) A játékmotorunknak nem lesznek olyan részei, amelyek meghibásodhatnak
            ideális körülmények között, így ezt a metrikát nem tudjuk alkalmazni.
        </li>
        <li>
            MTTR: (Mean Time To Repair) Amennyiben a játékmotor hibásodik meg, a fejlesztők számára a könyvtár frissítésére
            lesz szükség, amelyet a Maven Package Manager segítségével tudnak majd elvégezni. Mivel a tervezési fázis során
            nem tudjuk kitapasztalni hogy mennyi időt vehetnek igénybe az esetlegesen létrejövő hibák javítása, ezért ezt a
            metrikát sem tudjuk alkalmazni.
        </li>
        <li>
            A rendszer eredményeinek pontossága, felbontása: A játékmotorunk pontosságát az fogja befolyásolni, hogy a projektben
            milyen Tick-Rate -et szabunk meg, azaz milyen gyakran frissülnek a játékban elérhető rendszerek. Ezentúl a fizikai rendszert
            determinisztikusnak fogjuk tervezni, azaz a játék ugyanazon a kiindulási állapotokból ugyanazokat az eredményeket fogja
            produkálni.
        </li>
    </ul>
    <br>

    <h1>6. Teljesítmény</h1>
    <h2>Performance</h2>

    <p>
        A játékmotorunk teljesítményét a következők fogják befolyásolni:
    </p>
    <ul>
        <li>A játékmotorunknak több platformon is működnie kell.</li>
        <li>Gyorsnak kell maradnia régebbi gépeken is.</li>
    </ul>
    <p>
        Ezek alapján az alábbi értékek várhatóak:
    </p>
    <ul>
        <li>
            Válaszidők: A játékmotorunk úgy lesz felkészítve, hogy amennyiben megfelelő módon van alkalmazva a
            játékfejlesztők által, akkor a válaszidők minimálisak lesznek. Ez bitosítva lesz a UI könyvtárunkban,
            a logikai rendszerek alkalmazásában és a fizikai rendszerünkben is.
        </li>
        <li>
            Áteresztőképesség (fps, tps): Ezek a metrikák ideális körülmények között a meglehetősen magas értéket
            fogják elérni, mivel a játékmotorunkat úgy tervezzük, hogy a játékfejlesztőknek ne kelljen túl sokat
            törődniük a teljesítménnyel. Amennyiben megfelelően a dokumentáció szerint használják a játékmotorunkat,
            akkor performans marad a játék.
        </li>
        <li>
            Kapacitás (max entitások, max pályaméret): A játékmotorunk korlátait a 32-bites floating point számok
            határozzák meg a pályaméret során, és a 8-karakteres alfanumerikus azonosítók a maximális entitásszám
            során. Ezek a korlátok hozzávetőleg megfelelnek a jelenlegi játékmotorok korlátainak.
        </li>
        <li>
            Erőforrás igények: A játékmotorunkat úgy próbáljuk megtervezni, hogy a lehető legkevesebb erőforrást
            használja. Ennek köszönhetően elérhető, hogy régebbi hardvereken, és a dedikált grafikus kártyával nem
            rendelkező gépeken is futtatható legyen. Természetesen az igények ennek ellenére főként még mindig az
            adott játékfejlesztőtől függenek.
        </li>
    </ul>
    <br>

    <h1>7. Támogatottság</h1>
    <h2>Supportability</h2>

    <p>
        A játékmotorunk támogatottságát a következők fogják befolyásolni:
    </p>
    <ul>
        <li>
            Elnevezési konvenciók: A játékmotorunkban a Java nyelvben gyakran haszált elnevezési konvenciókat fogjuk
            használni, amely a camelCase változók esetén, és a PascalCase osztályok és metódusok esetén.
        </li>
        <li>
            Üzemeltetés: A játéknak a megfelelő Java verzióra lesz szüksége azon gépeken, amelyeken futtatni kívánjuk.
            Ezen kívül a játékmotorunknak a megfelelő OpenGL verzióra lesz szüksége, amelyet az Apple gépek korlátai miatt a 3.3-ra
            fogunk korlátozni.
        </li>
        <li>
            Naplózás: A játékmotorunk rendelkezni fog egy Logger osztállyal, amely a játékfejlesztők számára lehetővé teszi
            a játék futása során fellépő hibák naplózását. Ezen naplókat hibajelentés céljából el lehet majd küldeni a
            játékfejlesztőknek.
        </li>
    </ul>
    <br>

    <h1>8. Tervezési korlátozások</h1>
    <h2>Design constraints</h2>

    <p>
        A játékmotorunk tervezési korlátozásait a következők fogják befolyásolni:
    </p>
    <ul>
        <li>
            A játékmotorunkat Java nyelven fogjuk megírni, amelynek köszönhetően a játékfejlesztőknek nem kell
            külön platformokra külön-külön megírniuk a játékot. Viszont ez a korlát azt is jelenti, hogy a játék
            nem lesz olyan gyors, mint egy C++ nyelven megírt játék, illetve nem minden mobil platformot fog támogatni.
        </li>
        <li>
            A játékmotorunkat OpenGL használatával készítjük, amely elérhető rengeteg eszközön, viszont a vele elérhető
            maximális teljesítmény nem olyan magas, mint például a Vulkan API-é.
        </li>
        <li>
            Az ECS rendszer azt igényli, hogy a motor újrafordításra kerüljön minden egyes új komponens hozzáadásakor.
            Ez a korlát azt jelenti, hogy a játékfejlesztőknek nem lesz lehetőségük a játék futása során új komponenseket
            hozzáadni a játékhoz, ezentúl ez lassíthatja a játékfejlesztést.
        </li>
    </ul>
    <br>

    <h1>9. Online dokumentáció</h1>
    <h2>Online documentation</h2>

    <p>
        A játékmotorunkhoz egy online dokumentáció lesz elérhető, amelyet elsősorban JavaDocs formájában fogunk
        biztosítani. Ezen kívül a játékmotorunkhoz több példaprojekt is elérhető lesz, amelyek bemutatják a
        motor használatát.
    </p>
    <br>

    <h1>10. Felhasznált kész komponensek</h1>
    <h2>Used components</h2>

    <p>
        A játékmotorunkhoz a következő kész komponenseket fogjuk felhasználni:
    </p>

    <ul>
        <li>
            <a href="https://www.lwjgl.org/">LWJGL</a> - A játékmotorunkhoz használt OpenGL könyvtár.
            <p>Ennek a haszált alrészei: </p>
            <ul>
                <li>
                    OpenGL
                </li>
                <li>
                    GLFW
                </li>
                <li>
                    STBI
                </li>
                <li>
                    ASSIMP
                </li>
            </ul>
        </li>
        <br>
        <li>
            <a href="https://github.com/google/gson">GSON</a> - A játékmotorunkhoz használt könyvtár JSON fájlok kezelésére.
        </li>
    </ul>
    <p>
        Az LWJGL a következő licenc alatt érhető el: <a href="https://www.lwjgl.org/license">LWJGL License</a>
        Ennek köszönhetően a játékmotorunk ingyenesen alkalmazhatja ezt a könyvtárat.
    </p>
    <p>
        A GSON a következő licenc alatt érhető el: <a href="https://github.com/google/gson/blob/main/LICENSE">Apache-2.0 license</a>
        Ez a licensz is ingyenesen alkalmazható a játékmotorunkban.
    </p>
    <br>

    <h1>11. Interfészek</h1>
    <h2>Interfaces</h2>

    <h1>11.1. Felhasználói interfészek</h1>
    <h2>User interfaces</h2>

    <p>
        A játékmotor rendelkezni fog egy Immadiate Mode UI könyvtárral amely szerkesztés közbeni UI elemeket fog
        biztosítani a játékfejlesztők számára. Ezentúl a játékmotorunk rendelkezni fogy egy Retained Mode UI könyvtárral
        amely egy robosztusabb rendszer a már kész játékban használható UI elemekhez.
    </p>
    <br>

    <h1>11.2. Hardver interfészek</h1>
    <h2>Hardware interfaces</h2>

    <p>
        A játékmotorunk hardver iterfészek terén az OpenGL-t fogja használni, amely a legtöbb eszközön elérhető.
        Ezentúl egy alapvető, a futtatható alkalmazás mappájában történő fájlkezelőt fogunk biztosítani a játékfejlesztők
        számára, amely a játékban használt fájlok kezelésére lesz képes.
    </p>
    <br>

    <h1>11.3. Szoftver interfészek</h1>
    <h2>Software interfaces</h2>

    <p>
        A játékmotorunk a már előző pontokban felsorolt könyvtárak interfészeit fogja használni.
    </p>
    <br>

    <h1>12. Alkalmazott szabványok</h1>
    <h2>Applied standards</h2>

    <h1>12.1. Kötelezően alkalmazandó szabványok</h1>
    <h2>Mandatory standards</h2>

    <p>
        A játékmotorunk a következő szabványokat fogja alkalmazni:
    </p>
    <ul>
        <li>
            <a href="https://www.oracle.com/java/technologies/javase/codeconventions-introduction.html">Java Code Conventions</a>
        </li>
        <li>
            <a href="https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html">Java Naming Conventions</a>
        </li>
    </ul>
    <br>

    <h1>12.2. Választás alapján alkalmazott szabványok</h1>
    <h2>Choice-based standards</h2>

    <p>
        A játékmotorunk a következő szabványokat fogja alkalmazni:
    </p>
    <ul>
        <li>
            <a href="https://en.wikipedia.org/wiki/Entity_component_system">ECS</a>
        </li>
        <li>
            <a href="https://en.wikipedia.org/wiki/Physically_based_rendering">PBR</a>
        </li>
        <li>
            <a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">Determinisztikus Fizika</a>
        </li>
    </ul>
    <br>

    <h1>13. Mellékletek</h1>
    <h2>Attachments</h2>

    <p>
        Képek egy már működő prototípusról:
    </p>
    <img src="img/prototype1.png" alt="Prototype" width="512px">
    <p>
        Egy ábra a PBR anyagról. Balról jobbra haladva a fémesség nő, felülről lefelé haladva a simaság.
    </p>
    <br>
    <img src="img/prototype2.png" alt="Prototype2" width="512px">
    <p>
        Egy shell texturing segítségével készült szőr rajzolási teszt.
    </p>
    <br>
    <img src="img/prototype3.png" alt="Prototype3" width="512px">
    <br>
    <p>
        Egy bonyolultabb pályáról készült megvilágítási teszt.
    </p>
    <br>
    <img src="img/abra.png" alt="abra" width="512px">
    <p>
        A motorban már elérhető és jelenleg használt fontosabb objektumok.
    </p>

    <footer>
        <p>
            #2023, KRTN-Brigád, All rights reserved.
        </p>
    </footer>

</body>
</html>